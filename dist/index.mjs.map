{"version":3,"file":"index.mjs","sources":["../src/quantize.js"],"sourcesContent":["/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k, index;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = lh.size(),\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors);\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nexport default MMCQ.quantize\n"],"names":["pv","map","array","f","o","d","i","index","call","slice","naturalOrder","a","b","sum","reduce","p","max","Math","apply","sigbits","rshift","maxIterations","getColorIndex","r","g","PQueue","comparator","contents","sorted","sort","push","peek","undefined","length","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","this","CMap","vboxes","vbox","count","volume","medianCutApply","rw","gw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","min","doCut","prototype","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","palette","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","quantize","pixels","maxcolors","Array","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2","cmap"],"mappings":"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"}